<h1 id="handling-exceptions">Handling exceptions</h1>
<p><code>@ControllerAdvice</code>
<code>public class ErrorController {</code>
<code>...</code>
<code>@ExceptionHandler(AccessDeniedException.class)</code>
<code>@ResponseBody</code>
<code>@ResponseStatus(HttpStatus.FORBIDDEN)</code>
<code>public ErrorResponse accessDenied(AccessDeniedException e) {</code></p>
<h1 id="asynchronous-request-processing">Asynchronous request processing</h1>
<p>It is possible to use the Servlet 3.0 asynchronous request processing feature in Spring:
<code>@RequestMapping(method=RequestMethod.POST)</code>
<code>public Callable&lt;String&gt; processUpload(final MultipartFile file) {</code>
<code>return new Callable&lt;String&gt;() {</code>
<code>public String call() throws Exception {</code>
<code>// ...</code>
<code>return &quot;someView&quot;;</code>
<code>}</code>
<code>};</code>
<code>}</code></p>
<p>Or using DefferedResult
<code>@RequestMapping(&quot;/quotes&quot;)</code>
<code>@ResponseBody</code>
<code>public DeferredResult&lt;String&gt; quotes() {</code>
<code>DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;();</code>
<code>// Save the deferredResult somewhere..</code>
<code>return deferredResult;</code>
<code>}</code>
<code>// In some other thread...</code>
<code>deferredResult.setResult(data);</code></p>
